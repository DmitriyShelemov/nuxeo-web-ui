<!--
@license
(C) Copyright Nuxeo Corp. (http://nuxeo.com/)

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<link rel="import" href="../../bower_components/nuxeo-ui-elements/nuxeo-i18n-behavior.html">

<script>
  var Nuxeo = Nuxeo || {};

  (function() {
    /**
     * `Nuxeo.DiffBehavior`
     *
     * @polymerBehavior
     */
    Nuxeo.DiffBehavior = [Nuxeo.I18nBehavior, {
      properties: {
        property: {
          type: String,
          reflectToAttribute: true
        },
        schemaFields: Object,
        delta: Object,
        originalValue: String,
        type: {
          type: String,
          value: 'string',
          reflectToAttribute: true
        },
        level: {
          type: Number,
          value: 0
        },
        hideDeletions: {
          type: Boolean,
          value: false
        },
        hideAdditions: {
          type: Boolean,
          value: false
        },
        showAll: {
          type: Boolean,
          value: false
        }
      },

      /* helpers */

      _isOfType: function(type, target) {
        return type === target;
      },

      _isArray: function(value) {
        return Array.isArray(value);
      },

      _isObject: function(value) {
        return value && typeof value === 'object' && value.constructor === Object;
      },

      _isNotObjectNorArray: function(value) {
        return !this._isArray(value) && !this._isObject(value);
      },

      _getKeys: function(delta) {
        return Object.keys(delta);
      },

      _getValue: function(delta, property) {
        return delta && delta[property];
      },

      _getPropertySchemaFields: function(schemaFields, property) {
        return schemaFields && schemaFields[property] && schemaFields[property].fields;
      },

      _nochanges: function(delta) {
        return !delta;
      },

      /* simple */

      _added: function(delta, hideAdditions) {
        return !hideAdditions && Array.isArray(delta) && delta.length === 1;
      },

      _getAdded: function(delta) {
        return delta[0];
      },

      _modified: function(delta) {
        return Array.isArray(delta) && delta.length === 2;
      },

      _getModifiedOldValue: function(delta) {
        return delta[0];
      },

      _getModifiedNewValue: function(delta) {
        return delta[1];
      },

      _deleted: function(delta, hideDeletions) {
        return !hideDeletions && Array.isArray(delta) && delta.length === 3 && delta[2] === 0;
      },

      _getDeleted: function(delta) {
        return delta[0];
      },

      _moved: function(delta) {
        return Array.isArray(delta) && delta.length === 3 && delta[2] === 3;
      },

      _textDiff: function(delta) {
        return Array.isArray(delta) && delta.length === 3 && delta[2] === 2;
      },

      _simple: function(delta, type) {
        return delta && !this._complex(delta) && !this._complexArray(delta, type);
      },

      /* unidiff */

      _generateTextDiffHunks: function(text) {
        return text[0].split(/(@@[\s-+,\d]+@@)/).filter(Boolean).reduce(function(result, value, index, array) {
          if (index % 2 === 0) {
            var pair = array.slice(index, index + 2);
            var range = pair[0].match(/\d+,\d+/g);
            range = {
              original: range[0].split(',').map(Number),
              new: range[1].split(',').map(Number)
            }
            result.push({
              range: range,
              context: pair[1],
              hasAdditions: !!pair[1].match(/^\+(.*)$/gm),
              hasDeletions: !!pair[1].match(/^\-(.*)$/gm)
            });
          }
          return result;
        }, []);
      },

      _getTextDiff: function(text, originalValue, hideAdditions, hideDeletions) {
        if (!text || !originalValue) {
          return;
        }
        var hunks = this._generateTextDiffHunks(text);
        var result = '';
        var offset = 0;
        var start = 0;
        hunks.forEach(function(hunk){
          var end = hunk.range.original[0] - 1 + offset;
          result += originalValue.substring(start, end) + hunk.context
            .replace(/^\-(.*)$/gm, hideDeletions ? '' : '<span class="deleted">$1</span>') // removals
            .replace(/^\+(.*)$/gm, hideAdditions ? '' : '<span class="added">$1</span>') // deletions
            .replace(/^\s/gm, '') // modifier, which will by a black space for unmodified lines
            .replace(/(\r\n|\r|\n)/gm, ''); // new lines
          offset += hunk.range.original[1] - hunk.range.new[1];
          start += hunk.range.original[1] + (end - start);
        }.bind(this));
        return result;
      },

      /* handles better intercepting hunks */
      _getTextDiffV2: function(text, originalValue, hideAdditions, hideDeletions) {
        var hunks = this._generateTextDiffHunks(text);
        var result = originalValue;
        var offset = 0;
        hunks.forEach(function(hunk){
          if ((!hideDeletions || hunk.hasAdditions) && (!hideAdditions || hunk.hasDeletions)) {
            var substitute = hunk.context;
            var newOffset = offset;
            var base;
            if (hunk.hasDeletions) {
              substitute = substitute.replace(/^\-(.*)$/gm, hideDeletions ? '' : '<span class="deleted">$1</span>');
              if (!hideDeletions) {
                base = hunk.context.replace(/^\-(.*)$/gm, '');
                newOffset += this._sanitizeSubstitute(substitute).length - this._sanitizeSubstitute(base).length;
              }
            }
            if (hunk.hasAdditions) {
              substitute = substitute.replace(/^\+(.*)$/gm, hideAdditions ? '' : '<span class="added">$1</span>')
              if (!hideAdditions) {
                newOffset += 27; // this is just the lenght of <span class="added"></span>
              } else {
                base = hunk.context.replace(/^\+(.*)$/gm, '');
                newOffset -= this._sanitizeSubstitute(hunk.context).length - this._sanitizeSubstitute(base).length - 1;
              }
            }
            substitute = this._sanitizeSubstitute(substitute);
            result = this._replaceRange(result, hunk.range, offset, substitute);
            offset = newOffset;
          }
        }.bind(this));
        return result;
      },

      _sanitizeSubstitute: function(substitute) {
        return substitute.replace(/^\s/gm, '') // modifier, which will by a black space for unmodified lines
                         .replace(/(\r\n|\r|\n)/gm, ''); // new lines
      },

      _replaceRange: function(text, range, offset, substitute) {
        return text.substring(0, range.original[0] - 1 + offset) + substitute +
               text.substring(range.original[0] - 1 + range.original[1] + offset);
      },

      /* array */

      _array: function(delta, type) {
        return this._isObject(delta) && delta._t === 'a' && type !== 'complex[]';
      },

      _getArrayDelta: function(delta, originalValue, hideAdditions, hideDeletions) {
        if (!delta || !originalValue) {
          return;
        }
        var deltas = originalValue.map(function(val, index) {
          return { value: val, modified: false, index: String(index)};
        });
        // sort and reversing assures that we'll deal first with deletions
        Object.keys(delta).filter(function(key) { return key !== '_t' }).sort().reverse().forEach(function(index) {
          var i;
          if (index.startsWith('_')) {
            i = Number(index.replace('_', ''));
            if (hideDeletions) {
              deltas.splice(i, 1);
            } else {
              deltas.splice(i, 1, {
                value: delta[index],
                modified: false,
                change: 'deleted',
                originalValue: originalValue[i],
                index: String(i)
              });
            }
          } else {
            i = Number(index);
            if (this._isObject(delta[index])) {
              deltas.splice(i, 1, {
                value: delta[index],
                modified: true,
                change: 'modified',
                originalValue: originalValue[i],
                index: String(i)
              });
            } else if (!hideAdditions) {
              deltas.splice(i, 0, {
                value: delta[index],
                modified: false,
                change: 'added',
                originalValue: originalValue[i],
                index: String(i)
              });
            }
          }
        }.bind(this));
        deltas.sort(function(a, b) {
          if (a.index === b.index) {
            if (a.change === b.change) {
              return 0;
            }
            return a.change === 'added' ? 1 : -1;
          } else {
            return a.index > b.index;
          }
        });
        return deltas;
      },

      /* complex */

      _complex: function(delta) {
        return this._isObject(delta) && !delta._t;
      },

      _complexArray: function(delta, type) {
        if (!this._isObject(delta) || !delta._t) {
          return false;
        }
        var someKey = Object.keys(delta).filter(function(key) {
          return key !== '_t';
        })[0];
        var someValue = delta[someKey];
        return this._isObject((Array.isArray(someValue) && someValue.length) ? someValue[0] : someValue);
      }
    }];
  })();
</script>
